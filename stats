#!/usr/bin/env python
# -*- coding: UTF-8 -*-

import math
import sys
import os
try:
    from collections import Counter
except:
    def Counter(vals):
        d = {}
        for v in vals:
            if v not in d: d[v] = 0
            d[v] += 1
        return d

PY3 = False
if sys.version_info[0] >= 3:
    PY3 = True

if PY3:
    unichr = chr

def visible_len(val):
    try: val = val.decode("utf-8")
    except: pass
    lenval = len(val)
    if "\033" in val:
        lenval -= sum(map(len,re.findall(r"\033\[[0-9\;]+m",val)))
    return lenval

class Table():

    def __init__(self):
        self.matrix = []
        self.colnames = []
        self.colsizes = []
        self.hlines = []
        self.rowcolors = {}
        self.extra_padding = 1
        self.d_style = {}
        self.theme = ""
        self.set_theme_fancy()
        self.use_color = True

    def shorten_string(self, val, length):
        return val[:length//2-1] + "..." + val[-length//2+2:]
    def fmt_string(self, val, length, fill_char=" ", justify="c", bold=False, offcolor=False, color=None):
        ret = ""
        val = str(val)
        lenval = visible_len(val)

        if lenval > length: val = self.shorten_string(val, length)
        if justify == "l":
            nr = (length-lenval-1)
            ret = " " + val + fill_char*nr
        elif justify == "r": ret = val.rjust(length, fill_char)
        elif justify == "c":
            nl = (length-lenval)//2
            nr = (length-lenval)-(length-lenval)//2
            ret = fill_char*nl + val + fill_char*nr
        if bold and self.use_color:
            ret = '\033[1m' + ret + '\033[0m'
        if offcolor and self.use_color:
            ret = '\033[2m' + ret + '\033[0m'
        if self.use_color:
            if color == "green":
                ret = '\033[00;32m' + ret + '\033[0m'
            if color == "blue":
                ret = '\033[00;34m' + ret + '\033[0m'
            if color == "red":
                ret = '\033[00;31m' + ret + '\033[0m'
            if color == "lightblue":
                ret = '\033[38;5;117m' + ret + '\033[0m'
        return ret

    def set_theme_fancy(self):
        self.theme = "fancy"
        self.d_style["INNER_HORIZONTAL"] = '\033(0\x71\033(B'
        self.d_style["INNER_INTERSECT"] = '\033(0\x6e\033(B'
        self.d_style["INNER_VERTICAL"] = '\033(0\x78\033(B'
        self.d_style["OUTER_LEFT_INTERSECT"] = '\033(0\x74\033(B'
        self.d_style["OUTER_LEFT_VERTICAL"] = self.d_style["INNER_VERTICAL"]
        self.d_style["OUTER_RIGHT_INTERSECT"] = '\033(0\x75\033(B'
        self.d_style["OUTER_RIGHT_VERTICAL"] = self.d_style["INNER_VERTICAL"]
        self.d_style["OUTER_BOTTOM_HORIZONTAL"] = self.d_style["INNER_HORIZONTAL"]
        self.d_style["OUTER_BOTTOM_INTERSECT"] = '\033(0\x76\033(B'
        self.d_style["OUTER_BOTTOM_LEFT"] = '\033(0\x6d\033(B'
        self.d_style["OUTER_BOTTOM_RIGHT"] = '\033(0\x6a\033(B'
        self.d_style["OUTER_TOP_HORIZONTAL"] = self.d_style["INNER_HORIZONTAL"]
        self.d_style["OUTER_TOP_INTERSECT"] = '\033(0\x77\033(B'
        self.d_style["OUTER_TOP_LEFT"] = '\033(0\x6c\033(B'
        self.d_style["OUTER_TOP_RIGHT"] = '\033(0\x6b\033(B'

        self.d_style["OUTER_TOP_LEFT"] = '╭'
        self.d_style["OUTER_TOP_RIGHT"] = '╮'
        self.d_style["OUTER_BOTTOM_LEFT"] = '╰'
        self.d_style["OUTER_BOTTOM_RIGHT"] = '╯'

    def set_theme_basic(self):
        self.theme = "basic"
        self.use_color = False
        self.d_style["INNER_HORIZONTAL"] = '-'
        self.d_style["INNER_INTERSECT"] = '+'
        self.d_style["INNER_VERTICAL"] = '|'
        self.d_style["OUTER_LEFT_INTERSECT"] = '|'
        self.d_style["OUTER_LEFT_VERTICAL"] = '|'
        self.d_style["OUTER_RIGHT_INTERSECT"] = '+'
        self.d_style["OUTER_RIGHT_VERTICAL"] = '|'
        self.d_style["OUTER_BOTTOM_HORIZONTAL"] = '-'
        self.d_style["OUTER_BOTTOM_INTERSECT"] = '+'
        self.d_style["OUTER_BOTTOM_LEFT"] = '+'
        self.d_style["OUTER_BOTTOM_RIGHT"] = '+'
        self.d_style["OUTER_TOP_HORIZONTAL"] = '-'
        self.d_style["OUTER_TOP_INTERSECT"] = '+'
        self.d_style["OUTER_TOP_LEFT"] = '+'
        self.d_style["OUTER_TOP_RIGHT"] = '+'

    def add_row(self, row, color=None):
        self.matrix.append(row)
        if color:
            self.rowcolors[len(self.matrix)] = color

    def update(self):
        if not self.colnames:
            if self.matrix:
                self.colnames = range(1,len(self.matrix[0])+1)
        if self.matrix:
            for ic, cname in enumerate(self.colnames):
                self.colsizes.append( max(
                    max([visible_len(str(r[ic])) for r in self.matrix])+2,
                    len(str(cname))+2
                    ) )

    def get_table(self, **kwargs):
        return "".join(self.get_table_strings(**kwargs))

    def print_table(self, **kwargs):
        print(self.get_table(**kwargs))

    def get_table_strings(self, bold_title=True, show_row_separators=False, show_alternating=False, ljustall=True, show_colnames=False):
        self.update()
        nrows = len(self.matrix) + 1
        draw_row_separators = True
        draw_hlines = True

        for irow,row in enumerate([self.colnames]+self.matrix):

            # line at very top
            if irow == 0:
                yield self.d_style["OUTER_TOP_LEFT"]
                for icol,col in enumerate(row):
                    yield self.d_style["OUTER_TOP_HORIZONTAL"]*(self.colsizes[icol]+self.extra_padding)
                    if icol != len(row)-1: yield self.d_style["OUTER_TOP_INTERSECT"]
                yield self.d_style["OUTER_TOP_RIGHT"]+"\n"

            if not show_colnames and irow == 0: continue

            # lines separating columns
            yield self.d_style["OUTER_LEFT_VERTICAL"]
            oc = False if not show_alternating else (irow%2==1 )
            bold = False if not bold_title else (irow==0)
            color = self.rowcolors.get(irow,None)
            if irow == 0: color = "lightblue"
            for icol,col in enumerate(row):
                j = "l" if icol == 0 else "c"
                if ljustall: j = "l"
                yield self.fmt_string(col, self.colsizes[icol]+self.extra_padding, justify=j, bold=bold,offcolor=oc,color=color)
                if icol != len(row)-1: yield self.d_style["INNER_VERTICAL"]
            yield self.d_style["OUTER_RIGHT_VERTICAL"]+"\n"

            # lines separating rows
            if draw_row_separators and ((show_row_separators and (irow < nrows-1)) or (irow == 0)):
                yield self.d_style["OUTER_LEFT_INTERSECT"]
                for icol,col in enumerate(row):
                    yield self.d_style["INNER_HORIZONTAL"]*(self.colsizes[icol]+self.extra_padding)
                    if icol != len(row)-1: yield self.d_style["INNER_INTERSECT"]
                yield self.d_style["OUTER_RIGHT_INTERSECT"]
                yield "\n"

            # line at very bottom
            if irow == nrows-1:
                yield self.d_style["OUTER_BOTTOM_LEFT"]
                for icol,col in enumerate(row):
                    yield self.d_style["OUTER_BOTTOM_HORIZONTAL"]*(self.colsizes[icol]+self.extra_padding)
                    if icol != len(row)-1: yield self.d_style["OUTER_BOTTOM_INTERSECT"]
                yield self.d_style["OUTER_BOTTOM_RIGHT"]
            else:
                # extra hlines
                if draw_hlines and (irow in self.hlines):
                    yield self.d_style["OUTER_LEFT_INTERSECT"]
                    for icol,col in enumerate(row):
                        yield self.d_style["OUTER_TOP_HORIZONTAL"]*(self.colsizes[icol]+self.extra_padding)
                        if icol != len(row)-1: yield self.d_style["INNER_INTERSECT"]
                    yield self.d_style["OUTER_RIGHT_INTERSECT"]+"\n"

def hum(num, base2=False):
    if base2:
        if num < 1024**1:   return ('%.2f B'   % (num/1024**0))
        elif num < 1024**2: return ('%.2f KiB' % (num/1024**1))
        elif num < 1024**3: return ('%.2f MiB' % (num/1024**2))
        elif num < 1024**4: return ('%.2f GiB' % (num/1024**3))
        elif num < 1024**5: return ('%.2f TiB' % (num/1024**4))
        elif num < 1024**6: return ('%.2f PiB' % (num/1024**5))
        else: return '%.3g' % num
    # stolen from http://stackoverflow.com/questions/17973278/python-decimal-engineering-notation-for-mili-10e-3-and-micro-10e-6
    sgn = ''
    if num < 0: num, sgn = -num, '-'
    try: exp = int(math.floor(math.log10(num)))
    except: exp = 0
    exp3 = exp-(exp % 3)
    x3 = num/(10**exp3)
    if exp3 >= -24 and exp3 <= 24 and exp3 != 0:
        idxsi =  int(( exp3 - (-24)) / 3)
        exp3_text = 'yzafpnum kMGTPEZY'[idxsi]
    elif exp3 == 0: exp3_text = ''
    else: exp3_text = 'e%s' % exp3
    return '%s%s%s' % (sgn,round(x3,2),exp3_text)

def statistics(ls, base2=False):
    length = len(ls)
    totsum = sum(ls)
    mean = 1.0*totsum/length
    if length == 1:
        sigma = float("nan")
    else:
        sigma = math.sqrt(1.0*sum([(mean-v)*(mean-v) for v in ls])/(length-1))
    maximum, minimum = max(ls), min(ls)
    return (length, mean, sigma, totsum, minimum, maximum, \
           hum(length), hum(mean, base2=base2), \
           hum(sigma, base2=base2), hum(totsum, base2=base2), \
           hum(minimum, base2=base2), hum(maximum, base2=base2))

def makehisto(ls):
    d = dict(Counter(ls))
    maxval = max([d[k] for k in d.keys()])
    maxstrlen = max([len(k) for k in d.keys()])
    scaleto=80-maxstrlen
    for w in sorted(d, key=d.get, reverse=True):
        strbuff = "%%-%is | %%s (%%i)" % (maxstrlen)
        if(maxval < scaleto):
            print(strbuff % (w, "*" * d[w], d[w]))
        else: # scale to scaleto width
            print(strbuff % (w, "*" * max(1,int(float(scaleto)*d[w]/maxval)), d[w]))

def get_table(vals, do_unicode=True, width=80):
    d = dict(Counter(vals))
    maxval = max([d[k] for k in d.keys()])
    def shorten(label):
        return label[:50]
    maxstrlen = max([len(shorten(k)) for k in d.keys()])
    scaleto=width-maxstrlen
    fillchar = "*"
    if do_unicode:
        fillchar = unichr(0x2588)
        if not PY3:
            fillchar = fillchar.encode('utf-8')
    tab = Table()
    for w in sorted(d, key=d.get, reverse=True):
        nfill = d[w] if maxval < scaleto else max(1,int(float(scaleto)*d[w]/maxval))
        strbuff = "{0} ({1})".format(fillchar*nfill,d[w])
        shortw = shorten(w)
        tab.add_row([shortw,strbuff])
    return tab

if __name__ == "__main__":
    base2 = False
    column = -1
    if "-b" in sys.argv:
        base2 = True
        sys.argv.remove("-b")
    if(len(sys.argv) > 1): 
        column = int(sys.argv[-1])

    do_ascii = not sys.stdout.isatty()
    nums, words = [], []
    for item in sys.stdin:
        item = item.strip()
        if not item: continue
        try:
            if(column == -1): nums.append(float(item))
            else: nums.append(float(item.split()[column-1]))
        except:
            try:
                if(column == -1): words.append(item)
                else: words.append(item.split()[column-1])
            except: pass
        else: pass

    if(len(nums) < 1):
        if(len(words) < 1):
            print("No inputs!")
        else:
            if do_ascii:
                makehisto(words)
            else:
                get_table(words).print_table(ljustall=True, show_colnames=False)
    else:
        print("""
    length: {0} ({6})
    mean:   {1} ({7})
    sigma:  {2} ({8})
    sum:    {3} ({9})
    min:    {4} ({10})
    max:    {5} ({11})
        """.format(*statistics(nums, base2=base2)))
